import numpy as np
import pypinyin
from PIL import Image, ImageDraw
from moviepy.editor import ImageClip, CompositeVideoClip

from config.config import C
from model.models import Scene
from util.logger import logger
from steps.image.font import font_manager
from steps.video.base import VideoAssemblerBase

class BookVideoAssembler(VideoAssemblerBase):
    def _compose_scene(self, scene: Scene, visual_clip, duration: float):
        # Always use book layout clip
        narration_cn = getattr(scene, "narration_cn", "")
        # Use C.VIDEO_SIZE for consistent video dimensions
        video_size = C.VIDEO_SIZE if hasattr(C, "VIDEO_SIZE") else visual_clip.size

        narration_cn_str = str(narration_cn) if narration_cn is not None else "N/A"
        logger.info(
            f"   video_size={video_size}, narration='{scene.narration[:30]}...', narration_cn='{narration_cn_str[:20]}...'"
        )

        try:
            result = self.create_book_layout_clip(
                visual_clip,
                scene.narration,
                duration,
                video_size,
                subtitle_cn=narration_cn,
            )
            logger.info(f"   ‚úÖ create_book_layout_clip Ë∞ÉÁî®ÊàêÂäü")
            return result
        except Exception as e:
            logger.traceback_and_raise(
                Exception(f"   ‚ùå create_book_layout_clip Ë∞ÉÁî®Â§±Ë¥•: {e}")
            )
            return visual_clip

    def create_book_layout_clip(
        self,
        visual_clip,
        text: str,
        duration: float,
        video_size: tuple,
        subtitle_cn: str = "",
    ):
        W, H = video_size
        bg_clip = ImageClip(np.full((H, W, 3), 0, dtype=np.uint8)).set_duration(duration)

        # Aspect-Fill: Scale to cover target, then center crop
        src_w, src_h = visual_clip.size
        scale_w = W / src_w
        scale_h = H / src_h
        scale = max(scale_w, scale_h)  # Use max to ensure full coverage

        # üîç Ë∞ÉËØïÊó•Âøó
        logger.debug(
            f"üìù Â≠óÂπïÊ∏≤Êüì: text='{text[:30]}...', subtitle_cn='{subtitle_cn[:20] if subtitle_cn else 'None'}...'"
        )
        logger.debug(
            f"   ÂèåËØ≠Ê®°Âºè={C.IS_BILINGUAL_MODE_ENABLED}, has_subtitle_cn={bool(subtitle_cn)}"
        )

        scaled_clip = visual_clip.resize(scale)
        scaled_w, scaled_h = scaled_clip.size

        # Center crop to target size
        x_offset = (scaled_w - W) // 2
        y_offset = (scaled_h - H) // 2
        v_clip_resized = scaled_clip.crop(
            x1=x_offset, y1=y_offset, x2=x_offset + W, y2=y_offset + H
        ).set_position(("center", "center"))

        pane_height = int(H * 0.35)
        pane_bottom_margin = int(H * 0.15)
        pane_top = H - pane_height - pane_bottom_margin
        
        txt_img = Image.new("RGBA", (W, H), (0, 0, 0, 0))
        draw = ImageDraw.Draw(txt_img)
        
        pane_x_margin = int(W * 0.08)
        text_pad = int(W * 0.04)
        text_area_w = (W - 2 * pane_x_margin) - 2 * text_pad
        text_area_h = pane_height - 2 * text_pad
        text_start_x = pane_x_margin + text_pad
        text_start_y = pane_top + text_pad

        is_english = self._is_english_title(text)

        if C.IS_BILINGUAL_MODE_ENABLED and subtitle_cn:
            # --- Bilingual Mode (English + Chinese Pinyin) ---

            # 1. English (Top Half)
            base_font_size = int(W * 0.05)
            font_en = font_manager.get_font("english", base_font_size)

            # Wrap English
            words = text.split()
            lines = []
            current_line = []

            def get_line_width(line_words, f):
                return draw.textbbox((0, 0), " ".join(line_words), font=f)[2]

            for word in words:
                test_line = current_line + [word]
                if get_line_width(test_line, font_en) <= text_area_w:
                    current_line = test_line
                else:
                    if current_line:
                        lines.append(" ".join(current_line))
                    current_line = [word]
            if current_line:
                lines.append(" ".join(current_line))

            # üî• Ê∑ªÂä†ÈªëËâ≤ÂçäÈÄèÊòéËÉåÊôØÊ°Ü
            line_height = int(base_font_size * 1.3)
            total_text_h = len(lines) * line_height + 40  # English
            # È¢Ñ‰º∞‰∏≠ÊñáÈ´òÂ∫¶ÔºàÁÆÄÂåñÔºâ
            chinese_h = int(base_font_size * 0.8) + int(base_font_size * 0.8 * 0.6) + 30
            total_content_h = total_text_h + chinese_h

            box_pad = 15
            bg_box = [
                pane_x_margin,
                text_start_y - box_pad,
                W - pane_x_margin,
                text_start_y + total_content_h + box_pad,
            ]
            draw.rounded_rectangle(bg_box, radius=10, fill=(0, 0, 0, 140))

            # Draw English
            current_y = text_start_y

            for line in lines:
                w_line = draw.textbbox((0, 0), line, font=font_en)[2]
                x_line = text_start_x + (text_area_w - w_line) / 2
                draw.text(
                    (x_line, current_y), line, font=font_en, fill=(255, 255, 255, 255)
                )
                current_y += line_height

            current_y += 20  # Gap

            # 2. Chinese with Pinyin (Bottom Half)
            # Use smaller font
            fs_hanzi = int(base_font_size * 0.8)
            fs_pinyin = int(fs_hanzi * 0.6)
            font_hanzi = font_manager.get_font("chinese", fs_hanzi)
            font_pinyin = font_manager.get_font("chinese", fs_pinyin)

            pinyin_list = pypinyin.pinyin(subtitle_cn, style=pypinyin.Style.TONE)
            char_data = []

            # Calculate metrics
            line_overflow = False
            current_row_width = 0
            rows = []
            current_row = []

            spacing = 4

            for i, char in enumerate(subtitle_cn):
                # Simple Pinyin Layout Logic (Multi-line support needed?)
                # Bilingual subtitle usually short enough for 1-2 lines?
                # Let's support wrapping.
                pass

                bbox_c = draw.textbbox((0, 0), char, font=font_hanzi)
                w_char = bbox_c[2] - bbox_c[0]
                h_char = bbox_c[3] - bbox_c[1]

                p_str = pinyin_list[i][0] if i < len(pinyin_list) else ""
                bbox_p = draw.textbbox((0, 0), p_str, font=font_pinyin)
                w_pin = bbox_p[2] - bbox_p[0]
                h_pin = bbox_p[3] - bbox_p[1]

                cell_width = max(w_char, w_pin)

                if current_row_width + cell_width > text_area_w:
                    rows.append(current_row)
                    current_row = []
                    current_row_width = 0

                current_row.append(
                    {
                        "char": char,
                        "pinyin": p_str,
                        "w_char": w_char,
                        "h_char": h_char,
                        "w_pin": w_pin,
                        "h_pin": h_pin,
                        "cell_width": cell_width,
                    }
                )
                current_row_width += cell_width + spacing

            if current_row:
                rows.append(current_row)

            # Render Chinese Rows
            for row in rows:
                # Center row
                row_width = sum(d["cell_width"] + spacing for d in row) - spacing
                start_x = text_start_x + (text_area_w - row_width) / 2

                y_pinyin = current_y
                y_hanzi = y_pinyin + fs_pinyin + 2

                curr_x = start_x
                for item in row:
                    x_p = curr_x + (item["cell_width"] - item["w_pin"]) / 2
                    draw.text(
                        (x_p, y_pinyin),
                        item["pinyin"],
                        font=font_pinyin,
                        fill=(200, 200, 200, 255),
                    )

                    x_c = curr_x + (item["cell_width"] - item["w_char"]) / 2
                    draw.text(
                        (x_c, y_hanzi),
                        item["char"],
                        font=font_hanzi,
                        fill=(255, 230, 0, 255),
                    )

                    curr_x += item["cell_width"] + spacing

                current_y += fs_hanzi + fs_pinyin + 10

        elif is_english:
            base_font_size = int(W * 0.06)
            font = font_manager.get_font("english", base_font_size)
            words = text.split()
            lines = []
            current_line = []
            
            def get_line_width(line_words, f):
                return draw.textbbox((0, 0), " ".join(line_words), font=f)[2]

            for word in words:
                test_line = current_line + [word]
                if get_line_width(test_line, font) <= text_area_w:
                    current_line = test_line
                else:
                    if current_line: lines.append(" ".join(current_line))
                    current_line = [word]
            if current_line: lines.append(" ".join(current_line))

            max_lines = 4
            while len(lines) > max_lines and base_font_size > 20:
                base_font_size = int(base_font_size * 0.9)
                font = font_manager.get_font("english", base_font_size)
                lines = []
                current_line = []
                for word in words:
                    test_line = current_line + [word]
                    if get_line_width(test_line, font) <= text_area_w:
                        current_line = test_line
                    else:
                        if current_line: lines.append(" ".join(current_line))
                        current_line = [word]
                if current_line: lines.append(" ".join(current_line))

            line_height = int(base_font_size * 1.4)
            total_h = len(lines) * line_height
            start_y = text_start_y + (text_area_h - total_h) / 2
            
            box_pad = 15
            bg_box = [text_start_x - box_pad, start_y - box_pad, text_start_x + text_area_w + box_pad, start_y + total_h + box_pad]
            draw.rounded_rectangle(bg_box, radius=10, fill=(0, 0, 0, 140))

            current_y = start_y
            for line in lines:
                w_line = draw.textbbox((0, 0), line, font=font)[2]
                x_line = text_start_x + (text_area_w - w_line) / 2
                draw.text((x_line, current_y), line, font=font, fill=(255, 255, 255, 255))
                current_y += line_height
        
        else:
            fs_w = text_area_w / 20
            fs_h = text_area_h / 5
            font_size_hanzi = int(min(fs_w, fs_h))
            font_size_hanzi = max(font_size_hanzi, 24)
            font_size_pinyin = int(font_size_hanzi * 0.6)
            
            try:
                font_hanzi = font_manager.get_font("chinese", font_size_hanzi)
                font_pinyin = font_manager.get_font("chinese", font_size_pinyin)
            except Exception as e:
                logger.traceback_and_raise(Exception(f"Failed to load font: {e}"))
                return visual_clip
            
            chars_per_line = int(text_area_w / font_size_hanzi)
            chars_per_line = max(chars_per_line, 8)
            lines = [text[i : i + chars_per_line] for i in range(0, len(text), chars_per_line)]
            
            line_height = font_size_hanzi + font_size_pinyin + int(font_size_hanzi * 0.4)
            total_content_h = len(lines) * line_height
            start_y_offset = (text_area_h - total_content_h) / 2
            current_y = text_start_y + max(start_y_offset, 0)
            
            for line in lines:
                total_line_width = 0
                char_data = []
                pinyin_list = pypinyin.pinyin(line, style=pypinyin.Style.TONE)
                for i, char in enumerate(line):
                    bbox_c = draw.textbbox((0, 0), char, font=font_hanzi)
                    w_char = bbox_c[2] - bbox_c[0]
                    p_str = ""
                    if pinyin_list and i < len(pinyin_list) and pinyin_list[i]:
                        # pinyin_list[i] returns a list of phonetic notations, e.g. [['h√†o']]
                        # We take the first one.
                        try:
                            p_str = pinyin_list[i][0]
                        except:
                            pass
                    bbox_p = draw.textbbox((0, 0), p_str, font=font_pinyin)
                    w_pin = bbox_p[2] - bbox_p[0]
                    cell_width = max(w_char, w_pin)
                    char_data.append([char, w_char, p_str, w_pin, cell_width])
                    total_line_width += cell_width + 4
                
                line_start_x = text_start_x + (text_area_w - total_line_width) / 2
                current_x = line_start_x
                y_p = current_y
                y_h = y_p + font_size_pinyin + 3
                
                for c, wc, ps, wp, cw in char_data:
                    cell_h = (y_h + font_size_hanzi) - y_p + 4
                    draw.rectangle([current_x - 2, y_p - 2, current_x + cw + 2, y_p + cell_h + 2], fill=(0, 0, 0, 140))
                    draw.text((current_x + (cw - wc) / 2, y_h), c, font=font_hanzi, fill=(255, 255, 255, 255))
                    draw.text((current_x + (cw - wp) / 2, y_p), ps, font=font_pinyin, fill=(200, 200, 200, 255))
                    current_x += cw + 4
                current_y += line_height

        txt_clip = ImageClip(np.array(txt_img)).set_duration(duration).set_position(("center", "center"))
        return CompositeVideoClip([bg_clip, v_clip_resized, txt_clip], size=(W, H))
